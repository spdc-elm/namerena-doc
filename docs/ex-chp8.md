# Chapter 8 简易算号原理

“算号技术”一词，广义上包含了游戏在战斗开始前做出的所有名字计算处理，即，利用输入的字符串生成号的各项八围属性、技能、组队加成等信息的过程，是测号器的核心技术。<br>
虽然算号流程源代码严格来说也是 md5.js 的一部分，但由于主要应用在测号器上且很早就被完全解明并重写为其他语言，在开发上相对独立，因此通常和开箱技术分开讨论。

阅读具体的算号代码对基本的日常游玩过程帮助不大，但了解关键的算号步骤和其导出的常用二级结论则是必要的。

## 8.1 name\_base 与名字数值的生成

一个名字会根据某种特定方式生成一个包含 128 项的 name\_base 数列，其中 0~63 每个数各出现两次。号的属性、技能等数值的生成和 name\_base 息息相关。

### 8.1.1 八围属性

HP 对应 name\_base 中的某 10 项，其他七围属性分别对应某 3 项。

HP 的值为对应的 10 项从小到大排序后的中间四项之和 +154，其他七围属性为对应 3 项的中位数 +36。

因此，HP 的理论最低值是 166（对应排序后前七项 0,0,1,1,2,2,3），最高值是 398（对应排序后最大七项 60,61,61,62,62,63,63）；其他七围属性则有 36 的理论下限（对应 0,0,1）和 99 的上限（对应 62,63,63）。

### 8.1.2 技能熟练度

名竞中一共有 35 种技能，但一个名字只有 16 个“技能座位”，因此最多只能会 16 个技能（组队加成后也是如此），每个技能座位分别对应 name\_base 中的某 4 项。

技能熟练度的值为对应 4 项 name\_base 的最小值 -10，如果小于 0 则设为 0。

特别地：

- 最后一个主动技能的熟练度翻倍（如果存在熟练度不为 0 的主动技能），翻倍后的技能不会进行下一条规则判定。
- 如果最后两个技能座位上存在熟练度非零的技能，会将其熟练度增加某两项 name\_base 的最小值，双倍封顶（增加后若大于原熟练度二倍则会被强制设为原熟练度二倍）。

我们称这两条特殊规则为“末尾熟练度加成”，但请注意表述时不能将其简称为“加成”，在一般语境中“加成”一词均指组队加成。

技能熟练度的理论上限是 104（对应 62,62,63,63 的翻倍主动技）。也就是说，技能发动判定成功率 100%（要求熟练度至少 128）的情况是不存在的。

## 8.2 加成方式与加成潜力

### 8.2.1 组队加成的大致方式

组队加成的基本原理是按照一定的规则修改队伍中每个号的 name\_base 序列，从而影响它们的数值。由于队伍中号的 name\_base 不一定符合加成规则要求，name\_base 的改变也不一定会反映在号的数值上，所以有些时候会出现组队却没有加成的情况。

对于最简单的二人组，在进行加成时会分别扫描两个号 name\_base 的第 8~128 项，如果某个号 name\_base 的第 i 项同时满足：

- 与队友 name\_base 的第 i-1 项相等
- 大于队友 name\_base 的第 i 项

这两条，则会被打上加成标记。全部扫描完毕后，对于每个带有加成标记的位置，会将两个号在该位置上的 name\_base 值统一为较大者，最后用新的 name\_base 计算号的数值，这就完成了加成过程。由此可见，加成后属性超过理论上限的情况不可能出现，而技能熟练度最高可以达到 106。

例如，对于两个同队号 A 和 B，如果它们在某一 name\_base 区间上的序列片段分别为 \(0,1,2\) 和 \(3,2,60\)，那么在扫描 A 时会在该片段的最后一个位置打上加成标记，而对 B 的扫描不会产生标记。因此，最终的加成结果分别是 \(0,1,60\) 和 \(3,2,60\)。

需要注意的是，通过组队加成学会的新技能不会影响原来最后一个主动技的翻倍效果，也吃不到任何末尾熟练度加成。

### 8.2.2 加成潜力和双加成性质

由于同时加成两项位置相近 name\_base 位点的情况极难出现，根据名字数值的生成过程，我们可以知道，一些 name\_base 序列片段的加成会更容易在号的数值上反映出来。

例如，假设一个号的两个属性分别对应 \(30,30,60\) 和 \(30,30,31\)，对于前者，只要任意一个 30 得到加成就能立刻反映出来（因为 60 的存在使加成项稳坐中位），而对于后者，无论 30 被加成多少，最终的属性增益最多也只有 1 点（加成后中位数变为 31）。<br>
技能熟练度也是同理，\(20,50,50,60\) 很明显会比 \(20,20,50,60\) 更容易得到加成增益。

第 7 章中提到的“潜力丝评”就是在这一结论的基础上设计出来的。为了较为准确定量衡量一个号的加成潜力，我们采用这样的方式：将这个号的其中一个 name\_base 提升为 63 然后重新计算属性，用丝评模型预估；将每一个位置的 name\_base 都分别这样修改一次，选择最好的预估结果作为最终的潜力丝评。

除此之外，我们称形如 \(x,y,x\) 的序列片段（其中 y 是一个很大的数）具有“双加成性质”，当它匹配到该片段为 \(a,x,b\) 的队友时会被打上两处加成标记，更容易出现自己和队友都吃到数值增益的情况。

例如，假设一个号的某一属性对应 \(40,63,40\)，当它与这一属性对应 \(20,40,61\) 的队友组队时，加成结果分别是 \(40,63,61\) 和 \(20,63,61\)，最终两个号的该项属性都从原来的 76 提升到了 97。

## 8.3 算号小工具

在[资源文件下载页](res-files.md)中的 “exe-tools 常用工具集”处下载。

### 8.3.1 team\_calc

第 5 章中已经提到，team\_calc 可以计算组队加成。这里是计算加成的操作方法：

**team\_calc.html**<br>
输入一个多人组，按照换行分隔，他会告诉你加成后的属性是怎样的，同时提供 diy 格式。<br>
注意没有进行是否是同队的判断，请你自行保证输入的多人组是同队的。

**team\_calc.cpp**<br>
team\_calc.html 的缺点之一在于对某些字符会炸（尤其是各种奇怪的 Unicode，比如 emoji），同时不能批量。所以提供了一个 cpp，用法和 XP-convert 里的东西类似，用加号分隔多人组的每个号，用换行分隔不同多人组。

### 8.3.2 base

是“加成潜力”的具象化，一目了然，不言而喻。可能存在少量 bug。

输入在 `input.txt` 里，每行一个号，结尾换行。输出在 `base.txt` 里。
